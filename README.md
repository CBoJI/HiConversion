# Задание

Написать сервис регистрации по инвайту.

Основная логика работы:
 - на главной выводить 2 разные страницы: одна - для авторизованных (со сылкой “Выйти”), другая - для остальных (форма ввода логина и пароля)
 - при создании инвайта (в админке) уходит письмо на емейл счастливчика
 - в письме ссылка, при переходе по которой, создается юзер и авторизуется пользователь
 - после создания пользователю уходит емейл с логином и паролем

Дополнительные требования:
- инвайт не может быть использован повторно
- инвайт после использования должен быть привязан к пользователю
- наличие тестов
- в качестве базы - sqlite
- в качестве емейл бэкенда - консоль

### Версия python - 2.7.10

### Развертывание проекта:
Установка зависимостей
```
pip install -r requirements.txt
```
Запуск тестов
```
python manage.py test
```
Если все тесты прошли удачно, то развертываем проект:

- Создаем базу
```
python manage.py db upgrade
```
- Создаем пользователя с админскими правами
    ```login: admin@admin.ru```
    ```password: 123```
```
python manage.py set_admin admin@admin.ru 123
```
- Запускаем проект
```
export FLASK_CONFIG=production
python manage.py runserver -h 0.0.0.0 -p 5005
```
После развертывния проекта заходим на http://host:5005/ - страницы аутентификации. http://host:5005/admin - админка сервиса, которая доступна только для админов.

### Комментарии:
1) В данном задании использется консольный email-backend, который, конечно, не будет использоваться в настоящем сервере. В связи с этим в качестве модуля для отправки писем используется Flask-Mail, но для отправки писем в консоль используется [потомок класса Mail], в котором переопределены методы для данной задачи.

2) Использованы явно несвязанные между собой [таблицы пользователей и инвайтов]. Использована такая простая схема по следующим соображением:

    - инвайты и пользователи разделены из соображений нормализации и более быстрого select-а при аутентификации пользователя
    
    - на один email можно создать несколько инвайтов (например, если в будущем надо будет задать "время жизни" инвайта, но сохранить для истории все инвайты)
    
    - при создании пользователя записывается сам инвайт, хотя можно реализвать как ForeignKey на таблицу инвайтов. так как при больших рассылках придет время, когда надо будет чистить таблицу инвайтов, то таким образом мы не потеряем инвайт, по которому создавался пользователь. если инвайт нужен будет для чего-то более умного, то мы избавимся от join-а лишнего.
    
Вообщем, здесь надо более четко представлять картину бизнес-процессов для наиболее оптимальной схемы БД.
3) Уникальность инвайта обеспечивается модулем [uuid4]. Можно использовать [JWT], но он больше подходит для аутентификаций.
4) Валидация входных данных происходит и на frontend, и на [backend].
5) Из-за ограничей, указанных в задании (база sqlite), делал простую реализацию, хотя надо отметить, что для реального сервиса было бы лучше использовать следующее:
   - веб-сервер Nginx 
   - uwsgi
   - клиент-серверная БД, например, PostgreSql
   
    Если говорить о высоконагруженном сервисе, то опять-таки надо более четко представлять бизнес-процессы, и тогда часть функционала, отвечающую за генерацию инвайта, отправку письма, вынести в очередь задач (например, Celery), возможно, сам сервис переписать на асиннхронный (twisted или asyncio).
    
[потомок класса Mail]: <https://github.com/CBoJI/HiConversion/blob/master/app/extensions/custom_mail.py>
[таблицы пользователей и инвайтов]: <https://github.com/CBoJI/HiConversion/blob/master/app/auth/models.py#L54>
[uuid4]: <https://github.com/CBoJI/HiConversion/blob/master/app/auth/models.py#L122>
[JWT]: <https://jwt.io/>
[backend]: <https://github.com/CBoJI/HiConversion/blob/master/app/auth/forms.py>